import numpy as np

# it is used to check the version of the numpy we are currently using.
print(np.__version__)


# Difference between a common python array and numpy array . just analyze the differnce and - here is the reason that why we need numpy .

#This is how a Python array multiply the array with 2.
my_array = [1,2,3]*2
# check the array type
print(type(my_array))
print(my_array)


#This is how our numpy array creates.
#This is how a numpy array multiply the array with 2.
arr = np.array([1,2,3])*2
# check the array type
print(type(arr))
print(arr)

#Checks What is the dimensions of the numpy arrays.
print(arr.ndim)



# We can easily create nd.array from tuples , sets and arrays like objects.
arr = np.array((22,33,77))
print(arr)


# 0-D Arrays - Zero Dimensional Arrays:
# 0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.
arr = np.array(42)
print(arr.ndim)
print(arr)
#


# 1-D Arrays - One dimensional Arrays:
# An array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.
# These are the most common and basic arrays.
arr = np.array([1, 2, 3, 4, 5])
print(arr.ndim)
print(arr)


# 2-D Arrays - Two Dimensional Arrays:
# An array that has 1-D arrays as its elements is called a 2-D array.
# These are often used to represent matrix or 2nd order tensors.
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.ndim)
print(arr)



# 3-D arrays
# An array that has 2-D arrays (matrices) as its elements is called 3-D array.
# These are often used to represent a 3rd order tensor.
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])
print(arr.ndim)
print(arr)





# Higher Dimensional Arrays
# An array can have any number of dimensions.
# When the array is created, you can define the number of dimensions by using the ndmin argument.
airr= np.array([1,2,4,6],ndmin=6) # the maximum limit of the ndmin is 64. Not more than 64 is allowed to render the value
print(airr)

#NumPy Array Indexing -- Indexing in the numpy arrays
arr = [2,5,6,8,9]
print(arr[2])       #6


# Get third and fourth elements from the following array and add them
arr = [2,5,6,8,9]
print(arr[1]+arr[3])




# Access 2-D Arrays
arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
print(arr[0, 0])   #1
print(arr[1, 0])   #6



#Acess 3-D Arrays
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr[0, 0, 0])  #1
print(arr[0, 0, 1])  #2
print(arr[0, 0, 2])  #3
print(arr[0,1,0]) #4
print(arr[0,1,1]) #5
print(arr[0,1,2]) #6
print(arr[1,0,0])  #7
print(arr[1,0,1])  #8
print(arr[1,0,2])  #9
print(arr[1,1,0])   #10
print(arr[1,1,1])   #11
print(arr[1,1,2])   #12



#Slicing in the numpy arrays
# Note: The result includes the start index, but excludes the end index.

arr = np.array([1,2,3,4,5,6,7,8])
print(arr[:])           #prints the full array                               [1 2 3 4 5 6 7 8]
print(arr[:5])          #prints from starting to excluding given point       [1 2 3 4 5]
print(arr[2:])          #prints from 2nd index to the ending                 [3 4 5 6 7 8]
print(arr[1:6])         #prints from given value to excluding given value    [2 3 4 5 6]


# STEP
# Use the step value to determine the step of the slicing:
arr = np.array([1, 2, 3, 4, 5, 6, 7])
print(arr[0:6:3])


#Broadcasting: An introduction to broadcasting, which allows NumPy to perform element-wise operations on arrays of different shapes. This concept can help users avoid writing loops for certain operations.

arr = np.array([1, 2, 3])
arr2 = np.array([10])
print(arr + arr2)  # Broadcasting adds 10 to each element of arr: [11 12 13]




